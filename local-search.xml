<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Golang 中的错误处理与异常机制</title>
    <link href="/go-error/"/>
    <url>/go-error/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-中的错误处理与异常机制"><a href="#Golang-中的错误处理与异常机制" class="headerlink" title="Golang 中的错误处理与异常机制"></a>Golang 中的错误处理与异常机制</h1><p>Go（Golang）是一门以简洁、高效和并发性著称的编程语言。在 Go 中，错误处理是一等公民，采用了独特的方式来处理错误，而不是传统的 try-catch 异常机制。本文将深入探讨 Go 的错误处理模式，并通过代码示例来展示如何编写健壮的 Go 应用程序。</p><h2 id="Go-中的错误处理概述"><a href="#Go-中的错误处理概述" class="headerlink" title="Go 中的错误处理概述"></a>Go 中的错误处理概述</h2><p>在 Go 中，错误通过返回值来传递，而不是通过抛出异常。这使得错误处理更加显式，鼓励开发者在每个可能出错的地方都进行检查。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 执行一些操作</span><br>    <span class="hljs-keyword">if</span> failure &#123;<br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;something went wrong&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用该函数时，需要检查返回的错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">err := doSomething()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)<br>    <span class="hljs-comment">// 处理错误</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内置的-error-接口"><a href="#内置的-error-接口" class="headerlink" title="内置的 error 接口"></a>内置的 <code>error</code> 接口</h2><p>Go 提供了一个内置的 <code>error</code> 接口，用于表示错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>任何实现了 <code>Error()</code> 方法的类型都可以作为错误使用。</p><h3 id="示例：自定义错误类型"><a href="#示例：自定义错误类型" class="headerlink" title="示例：自定义错误类型"></a>示例：自定义错误类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;<br>    Code    <span class="hljs-type">int</span><br>    Message <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MyError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Error %d: %s&quot;</span>, e.Code, e.Message)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用自定义错误类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 发生错误</span><br>    <span class="hljs-keyword">return</span> &amp;MyError&#123;Code: <span class="hljs-number">404</span>, Message: <span class="hljs-string">&quot;Resource not found&quot;</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误包装（Error-Wrapping）"><a href="#错误包装（Error-Wrapping）" class="headerlink" title="错误包装（Error Wrapping）"></a>错误包装（Error Wrapping）</h2><p>Go 1.13 引入了错误包装机制，允许在保留原始错误的情况下添加上下文信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>    data, err := ioutil.ReadFile(filename)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to read file %s: %w&quot;</span>, filename, err)<br>    &#125;<br>    <span class="hljs-keyword">return</span> data, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>%w</code> 进行错误包装，可以在调用方解包错误。</p><h3 id="解包错误"><a href="#解包错误" class="headerlink" title="解包错误"></a>解包错误</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">data, err := readFile(<span class="hljs-string">&quot;test.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">if</span> errors.Is(err, os.ErrNotExist) &#123;<br>        fmt.Println(<span class="hljs-string">&quot;File does not exist.&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Panic-和-Recover"><a href="#Panic-和-Recover" class="headerlink" title="Panic 和 Recover"></a>Panic 和 Recover</h2><p>虽然 Go 不鼓励使用异常处理，但仍提供了 <code>panic</code> 和 <code>recover</code> 用于处理不可恢复的错误。</p><h3 id="使用-panic"><a href="#使用-panic" class="headerlink" title="使用 panic"></a>使用 <code>panic</code></h3><p><code>panic</code> 会立即中止当前函数的执行，直到程序崩溃或被 <code>recover</code> 捕获。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;division by zero&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> a / b<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-recover"><a href="#使用-recover" class="headerlink" title="使用 recover"></a>使用 <code>recover</code></h3><p><code>recover</code> 可以捕获 <code>panic</code>，避免程序崩溃。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">safeDivide</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Recovered from panic:&quot;</span>, r)<br>        &#125;<br>    &#125;()<br>    result := divide(a, b)<br>    fmt.Println(<span class="hljs-string">&quot;Result:&quot;</span>, result)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实践示例：并发错误处理"><a href="#实践示例：并发错误处理" class="headerlink" title="实践示例：并发错误处理"></a>实践示例：并发错误处理</h2><p>在并发程序中，错误处理可能会更加复杂。下面是一个使用 Goroutine 和 Channel 的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(id <span class="hljs-type">int</span>, jobs &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, results <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>, errs <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">error</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> jobs &#123;<br>        <span class="hljs-keyword">if</span> j%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>            errs &lt;- errors.New(fmt.Sprintf(<span class="hljs-string">&quot;Worker %d: error processing job %d&quot;</span>, id, j))<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;Worker %d processing job %d\n&quot;</span>, id, j)<br>        results &lt;- j * <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    jobs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br>    results := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br>    errs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">5</span>)<br><br>    <span class="hljs-keyword">for</span> w := <span class="hljs-number">1</span>; w &lt;= <span class="hljs-number">3</span>; w++ &#123;<br>        <span class="hljs-keyword">go</span> worker(w, jobs, results, errs)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">5</span>; j++ &#123;<br>        jobs &lt;- j<br>    &#125;<br>    <span class="hljs-built_in">close</span>(jobs)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> res := &lt;-results:<br>            fmt.Println(<span class="hljs-string">&quot;Result:&quot;</span>, res)<br>        <span class="hljs-keyword">case</span> err := &lt;-errs:<br>            fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Worker 1 processing job 1<br>Worker 2 processing job 3<br>Worker 3 processing job 5<br><span class="hljs-keyword">Error: </span>Worker 2: error processing job 2<br><span class="hljs-keyword">Error: </span>Worker 1: error processing job 4<br>Result: 2<br>Result: 6<br>Result: 10<br></code></pre></td></tr></table></figure><h2 id="使用-defer-简化错误处理"><a href="#使用-defer-简化错误处理" class="headerlink" title="使用 defer 简化错误处理"></a>使用 <code>defer</code> 简化错误处理</h2><p><code>defer</code> 语句可以在函数返回之前执行，常用于资源释放和错误处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> (data []<span class="hljs-type">byte</span>, err <span class="hljs-type">error</span>) &#123;<br>    file, err := os.Open(filename)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> cerr := file.Close(); cerr != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// 如果关闭文件时发生错误，覆盖返回的错误</span><br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                err = cerr<br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> ioutil.ReadAll(file)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>错误处理在 Go 中是一个核心概念，通过显式的错误返回和检查，可以编写出更加健壮和可靠的代码。理解 Go 的错误处理机制，对于编写高质量的 Go 程序至关重要。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://golang.org/doc/effective_go.html#errors">Go 官方文档 - 错误处理</a></li><li><a href="https://blog.golang.org/error-handling-and-go">Go Blog - Error Handling and Go</a></li><li><a href="https://github.com/golang/go/wiki/ErrorHandling">Go Wiki - Error Handling</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 并发编程入门</title>
    <link href="/goroutine/"/>
    <url>/goroutine/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-并发编程入门"><a href="#Golang-并发编程入门" class="headerlink" title="Golang 并发编程入门"></a>Golang 并发编程入门</h1><p>Go（又称 Golang）是一种开源的编程语言，因其内置的并发特性而备受关注。在这篇博客中，我们将介绍 Go 的并发编程模型，并通过代码示例来展示如何在 Go 中实现并发。</p><h2 id="什么是并发？"><a href="#什么是并发？" class="headerlink" title="什么是并发？"></a>什么是并发？</h2><p>并发是指在同一时间段内处理多件事情。在编程中，并发允许我们同时执行多个任务，从而提高程序的效率和性能。</p><h2 id="Go-中的并发"><a href="#Go-中的并发" class="headerlink" title="Go 中的并发"></a>Go 中的并发</h2><p>Go 提供了轻量级的协程（goroutine）和通道（channel）来实现并发。goroutine 是由 Go 运行时管理的轻量线程，而 channel 则用于 goroutine 之间的通信。</p><h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><p>要启动一个新的 goroutine，只需在函数调用前加上 <code>go</code> 关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> sayHello()<br>    time.Sleep(time.Second)<br>    fmt.Println(<span class="hljs-string">&quot;Main function ends&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hello, World!<br>Main <span class="hljs-keyword">function</span> <span class="hljs-title">ends</span><br></code></pre></td></tr></table></figure><p>在上述代码中，<code>sayHello()</code> 函数在一个新的 goroutine 中执行，而主函数会等待一秒钟，然后打印 “Main function ends”。</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 是 Go 中用于 goroutine 之间通信的管道。它可以发送和接收特定类型的值。</p><h4 id="创建一个-Channel"><a href="#创建一个-Channel" class="headerlink" title="创建一个 Channel"></a>创建一个 Channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><h4 id="发送和接收数据"><a href="#发送和接收数据" class="headerlink" title="发送和接收数据"></a>发送和接收数据</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 发送数据到 channel</span><br>ch &lt;- <span class="hljs-number">42</span><br><br><span class="hljs-comment">// 从 channel 接收数据</span><br>value := &lt;-ch<br></code></pre></td></tr></table></figure><h3 id="使用-Goroutine-和-Channel-的示例"><a href="#使用-Goroutine-和-Channel-的示例" class="headerlink" title="使用 Goroutine 和 Channel 的示例"></a>使用 Goroutine 和 Channel 的示例</h3><p>下面是一个使用 goroutine 和 channel 计算数字之和的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(numbers []<span class="hljs-type">int</span>, result <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    total := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> numbers &#123;<br>        total += num<br>    &#125;<br>    result &lt;- total<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    numbers := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    result := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br>    <span class="hljs-keyword">go</span> sum(numbers[:<span class="hljs-built_in">len</span>(numbers)/<span class="hljs-number">2</span>], result)<br>    <span class="hljs-keyword">go</span> sum(numbers[<span class="hljs-built_in">len</span>(numbers)/<span class="hljs-number">2</span>:], result)<br><br>    sum1, sum2 := &lt;-result, &lt;-result<br><br>    fmt.Println(<span class="hljs-string">&quot;Total Sum:&quot;</span>, sum1+sum2)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Total</span> <span class="hljs-built_in">Sum</span><span class="hljs-operator">:</span> <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>在这个示例中，我们将数字列表拆分为两部分，并在两个 goroutine 中分别计算其和。最终，将结果相加得到总和。</p><h2 id="使用-WaitGroup-同步-Goroutine"><a href="#使用-WaitGroup-同步-Goroutine" class="headerlink" title="使用 WaitGroup 同步 Goroutine"></a>使用 WaitGroup 同步 Goroutine</h2><p><code>sync.WaitGroup</code> 是 Go 标准库中用于等待一组 goroutine 完成的工具。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(id <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br>    fmt.Printf(<span class="hljs-string">&quot;Worker %d starting\n&quot;</span>, id)<br>    <span class="hljs-comment">// 模拟工作</span><br>    fmt.Printf(<span class="hljs-string">&quot;Worker %d done\n&quot;</span>, id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> worker(i, &amp;wg)<br>    &#125;<br><br>    wg.Wait()<br>    fmt.Println(<span class="hljs-string">&quot;All workers done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Worker</span> <span class="hljs-number">1</span> starting<br><span class="hljs-attribute">Worker</span> <span class="hljs-number">2</span> starting<br><span class="hljs-attribute">Worker</span> <span class="hljs-number">3</span> starting<br><span class="hljs-attribute">Worker</span> <span class="hljs-number">4</span> starting<br><span class="hljs-attribute">Worker</span> <span class="hljs-number">5</span> starting<br><span class="hljs-attribute">Worker</span> <span class="hljs-number">1</span> done<br><span class="hljs-attribute">Worker</span> <span class="hljs-number">2</span> done<br><span class="hljs-attribute">Worker</span> <span class="hljs-number">3</span> done<br><span class="hljs-attribute">Worker</span> <span class="hljs-number">4</span> done<br><span class="hljs-attribute">Worker</span> <span class="hljs-number">5</span> done<br><span class="hljs-attribute">All</span> workers done<br></code></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Go 的并发特性使其在处理多任务和高性能应用时表现出色。通过 goroutine 和 channel，可以轻松地编写并发程序。希望这篇博客能帮助你入门 Go 的并发编程。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://golang.org/doc/">Go 官方文档</a></li><li><a href="https://golang.org/doc/effective_go.html#concurrency">Go 并发编程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
